## Composable Example: Local Storage
Local storage is commonly used for things like forms. It temporarily holds data in local storage, meaning if a user navigates away from the page, accidentlly refreshes etc. they wont lose all of the changes that they had made to the form.

### Adding to localStorage
We can add items using the methods available via the `localStorage API`.

For example an input could be setup to listen for any input, reactively track it and add it to `localStorage`

```js
const food = ref('')

const storeFood = () => {
    localStorage.setItem('food', food.value)
}

<template>
    <label>Tell us your favourite food</label>
    <input type="text" v-model="food" @input="storeFood">
```

Now when the user inputs their favourite food the value will be written to local storage with the key 'food'.

### Retrieving from localStorage
So the key/value is now stored in loaclStorage but if the page is refreshed the input is still lost so it's not really useful to the user. 

To prevent this the `localStorage.getItem()` method can be called to retrieve data stored in loaclStorage. This can be used to initialise the ref() instead of an empty string and is safe to use even when the key doesnt exist.

```js
const food = ref(localStorage.getItem('food'));
```

*More information on the localStorage API can be found at [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage#examples)*

### Watchers
Rather than having an event listener on the input another approach would be to setup a watcher instead.
```js
watch(food, (newVal) => {
  localStorage.setItem('food', newVal)
})
```

But this still creates a situation where duplication would be required to track all of the different form inputs which, in a real project could be many.

This is a good opportunity to leverage `Composables`.

### Composables
A composable is a function that leverages Vue's `Composition API` to encapsulate and reuse stateful logic. This is ideal for this type of scenario.

By convention composables live in their own directory alongside views etc. The reptitive logic is then moved from the main template to the composable file.

```js
import { ref, watch } from "vue"

/**
 * Watches a reactive property and updates the value stored in local storage.
 * Accepts one argument which is the key of the value to be stored.
 */
export function useStorage(key) {
    // Gets stored value for key. Is NULL if no value stored yet
    let storedValue = localStorage.getItem(key)

    // Makes the value reactive
    let value = ref(storedValue)

    // Watches for any changes in the value and updates local storage
    watch(value, (newVal) => {
        localStorage.setItem(key, newVal)
    })

    return value
}
```

When working with serialised data such as arrays and objects use `JSON.stringify()` to store it and `JSON.parse()` when fetching the data.

`JSON.stringify()` will convert the object into a string whereas `JSON.parse()` will convert the data back into an object when it is fetched.

#### Deep Watchers
If working with a reactive object it may be necessary to setup a deep watcher which will watch for changes at a deeper level than just the object itself.

```js
watch(val, write, { deep:true })
```

**BE AWARE:** This can have significant performance overhead, especially when working with larger objects.